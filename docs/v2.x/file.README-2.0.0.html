<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README-2.0.0
  
    &mdash; ruby-jss-2.0.0a10
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "README-2.0.0";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README-2.0.0</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="ruby-jss-20-combined-access-to-the-classic-and-jamf-pro-apis">ruby-jss 2.0: Combined access to the Classic and Jamf Pro APIs</h1>

<p>Version 2.0.0 is a major refactoring of ruby-jss. While attempting to provide as much backward compatibility as possible, there are some significant changes under the hood. <strong><em>PLEASE TEST YOUR CODE EXTENSIVELY</em></strong></p>

<p>This document discusses the high-level changes, listing the detailed changes that have already happened, as well as planned changes and deprecations. It also provides some discussion and background around all of this. It is a work-in-progress at the moment, and hopefully will prompt discussion and decision-making in the #ruby-jss channel of MacAdmins Slack (Please join us!)</p>

<p>These changes have been in mind for some time, but the ability (soon to be requirement) for the Classic API to authenticate with Bearer Tokens from the Jamf Pro API means that the time has come, so here we are!</p>

<p><strong>CONTENTS</strong></p>

<!-- TOC depthFrom:2 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

<ul>
  <li><a href="#requirements">Requirements</a></li>
  <li><a href="#high-level-changes">High level changes</a>
    <ul>
      <li><a href="#ruby-3x-support">Ruby 3.x support</a></li>
      <li><a href="#combined-api-access">Combined API access</a>
        <ul>
          <li><a href="#a-single-connection-class">A single Connection class</a>
            <ul>
              <li><a href="#connecting-to-the-api">Connecting to the API</a>
                <ul>
                  <li><a href="#the-default-connection">The default connection</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#a-single-namespace-jamf">A single namespace <code>Jamf</code></a>
            <ul>
              <li><a href="#inherant-differences-between-the-apis">Inherant differences between the APIs</a></li>
              <li><a href="#which-api-does-an-object-come-from">Which API does an object come from?</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#automatic-code-generation">Automatic code generation</a></li>
      <li><a href="#autoloading-with-zeitwerk">Autoloading with Zeitwerk</a></li>
    </ul>
  </li>
  <li><a href="#notable-changes-from-ruby-jss-1x">Notable changes from ruby-jss 1.x</a>
    <ul>
      <li><a href="#paged-queries-to-the-jamf-pro-api">Paged queries to the Jamf Pro API</a></li>
      <li><a href="#api-data-are-no-longer-cached-">API data are no longer cached (?)</a></li>
      <li><a href="#no-attribute-aliases-for-jamf-pro-api-objects">No Attribute aliases for Jamf Pro API objects</a></li>
      <li><a href="#classmixin-hierarchy-for-jamf-pro-api-objects">Class/Mixin hierarchy for Jamf Pro API objects</a></li>
    </ul>
  </li>
  <li><a href="#planned-deprecations">Planned deprecations</a>
    <ul>
      <li><a href="#use-of-the-term-api-in-method-names-parameter-names-and-attributes">Use of the term ‘api’ in method names, parameter names, and attributes</a></li>
      <li><a href="#map_all_ids_to-method-for-classic-api-collection-classes"><code>.map_all_ids_to</code> method for Classic API collection classes</a></li>
      <li><a href="#using-make-create-and-update-for-classic-api-objects">Using <code>.make</code>, <code>#create</code>, and <code>#update</code> for Classic API objects</a></li>
      <li><a href="#jssconfig">JSS::CONFIG</a></li>
      <li><a href="#jamfconnection-instance-methods-next_refresh-secs_to_refresh---time_to_refresh">Jamf::Connection instance methods <code>#next_refresh</code>, <code>#secs_to_refresh</code>, &amp;  <code>#time_to_refresh</code></a></li>
      <li><a href="#cross-object-validation-in-setters">Cross-object validation in setters</a></li>
      <li><a href="#fetch-random">.fetch :random</a></li>
    </ul>
  </li>
  <li><a href="#how-to-install-for-testing">How to install for testing</a></li>
  <li><a href="#contact">Contact</a></li>
</ul>

<!-- /TOC -->

<h2 id="requirements">Requirements</h2>

<p>ruby-jss 2.0.0 requires ruby 2.7 or higher , and a Jamf Pro server running version 10.35 or higher.</p>

<h2 id="high-level-changes">High level changes</h2>

<h3 id="ruby-3x-support">Ruby 3.x support</h3>

<p>The plan is for ruby-jss 2.0+ to be compatible with ruby 2.7 and higher, including ruby 3.x</p>

<p>As of this writing, basic access to the API seems to be working in ruby 3, but much much more testing is needed.</p>

<p>It looks like the biggest changes have been dealing with keyword arguments as Hashs.  Methods defined with <code>def methodname([...] foo = {}</code> need to be changed to <code>def methodname([...] **foo</code> and calls to those methods, even in your own code, need to be changed to <code>methodname([...] **foo)</code> when <code>foo</code> is a hash of keyword args.</p>

<p><strong>IMPORTANT</strong>: do not pass raw hashes as ‘keyword’ args.  Instead use the double-splat: <code>methodname(**hash)</code> which should be compatible with ruby 3.x and 2.7.x</p>

<p>for more info see <a href="https://www.ruby-lang.org/en/news/2019/12/12/separation-of-positional-and-keyword-arguments-in-ruby-3-0/">Separation of positional and keyword arguments in Ruby 3.0</a></p>

<h3 id="combined-api-access">Combined API access</h3>

<p>ruby-jss has always used the <code>JSS</code> module to encapsulate all access to the Classic API. When the Jamf Pro API became a thing, the <code>Jamf</code> module was created as the way to interact with that API as it grew and developed.</p>

<p>Even though the latest Jamf Pro release notes say the Jamf Pro API is still officially “open for user testing”, it has stablized enough that it is used by many folks for production work.</p>

<p>The announcement with Jamf Pro 10.35 that the Classic API can use, and will eventually require, a Bearer Token from the Jamf Pro API meant that it was time to merge the two in ruby-jss.</p>

<h4 id="a-single-connection-class">A single Connection class</h4>

<p>There is now one <code>Jamf::Connection</code> class, instances of which are connections to a Jamf Pro server. Once connected, the connection instance maintains connections to <em>both</em> APIs and other classes use them as needed. As before, there are low-level methods available for sending HTTP requests manually, which are specific to each API. See the documentation for <code>Jamf::Connection</code> (link TBA) for details.</p>

<h5 id="connecting-to-the-api">Connecting to the API</h5>

<p>Most of the previous methods and parameters for making API connections to either API should still work, including using a URL rather than individual connection parameters. So both of these are valid and identical:</p>

<p>```ruby
a_connection = Jamf::Connection.new ‘https://apiuser@my.jamf.server:8443/’, pw: :prompt</p>

<p>another_connection = Jamf::Connection.new host: ‘my.jamf.server’, port: 8443, user: ‘apiuser’, pw: :prompt
```</p>

<p>Other connection parameters can be passed in as normal.</p>

<h6 id="the-default-connection">The default connection</h6>

<p>The top-level module methods for accessing the ‘default’ connection are still available and are now synonyms: <code>Jamf.cnx</code> and <code>JSS.api</code> both return the current default Jamf::Connection instance. There is also a top-level methods<code>Jamf.connect</code> which is the same as <code>Jamf.cnx.connect</code>. The top-level methods for changing the default connection are still there. The use of <code>JSS::API</code> has been deprecated for years now, and still is (see below).</p>

<h4 id="a-single-namespace-jamf">A single namespace <code>Jamf</code></h4>

<p>Version 2.0.0 combines the <code>JSS</code> module and the <code>Jamf</code> module into a single <code>Jamf</code> module, with <code>JSS</code> aliased to it. This means you can use them interchangably to refer to the Jamf module, and existing code that used either should still work. The module name no longer indicates which API you’re working with.</p>

<p>For example, the <code>JSS::Computer</code> class, from the Classic API, is still a thing, but now just points to the <code>Jamf::Computer</code> class, still from the Classic API.  The <code>Jamf::InventoryPreloadRecord</code> class, from the Jamf Pro API remains as is, but can also be referred to as <code>JSS::InventoryPreloadRecord</code></p>

<h5 id="inherant-differences-between-the-apis">Inherant differences between the APIs</h5>

<p>In theory, you shouldn’t need to worry about which classes and objects come from which API - you can just <code>.fetch</code>, <code>.create</code>, <code>.save</code>, etc.. and ruby-jss will deal with the API interaction for you.</p>

<p>However, in reality the two APIs have different functionality, some of which must be reflected in the ruby classes that represent objects in those APIs.</p>

<p>Take, for example, the classes for ‘Collection Resources’ - API endpoints that let you deal with collections of objects like Computers, or Inventory Preload Records.  These classes implement a <code>.all</code> class method, which retrieves a list of some data about all members of the collection.</p>

<p>Not only is the data returned in such lists very different between the APIs, but in the Jamf Pro API, you can ask the server to return the list already sorted, possibly filtered, or ‘paged’ in groups of some number of items. None of that is possible in the Classic API.</p>

<p>The <code>.all</code> method, and its relatives like <code>.all_ids</code>, <code>.all_names</code>, etc. exist for Collection Resources in both APIs, but the methods take different parameters, e.g. to deal with sorting and filtering. Jamf Pro API classes have a <code>.pager</code> method which returns an object from which you can retrieve the ‘pages’ of your query.</p>

<h5 id="which-api-does-an-object-come-from">Which API does an object come from?</h5>

<p>To confirm which API a class comes from, just look at its <code>API_SOURCE</code> constant, e.g. <code>Jamf::Computer::API_SOURCE</code>. This constant will return a symbol, either <code>:classic</code> or <code>:jamf_pro</code></p>

<h3 id="automatic-code-generation">Automatic code generation</h3>

<p>While the Classic API classes in ruby-jss are very hand-built and must be manually edited to add access to new data, the Jamf Pro API has an OpenAPI3 specification - a JSON document that fully describes the entire API and what it can do.</p>

<p>The API documentation you see at your own Jamf Pro server at https://your.jamf.server/api/doc/ is generated from the OAPI specification. The specification itself can be seen at https://your.jamf.server/api/schema.</p>

<p>In ruby-jss 2.0 and up, the OAPI spec is used to automatically generate hundreds of ‘base’ classes in ruby-jss, each with automatically generated attribute getters, setters, validators, and other useful methods. These base classes can then be used as the superclasses of the Jamt Pro API objects we implement for direct use in ruby-jss - and the majority of the coding is already done! The subclasses implementing objects in ruby-jss can then be expanded and customized beyond the simple, auto-generated superclass.</p>

<p>Not only does this make it fast and simple to implement new objects in ruby-jss, but allows fast and simple updates to existing objects, when new functionality is introduced to the API.</p>

<p>If you develop ruby-jss, please see (documentation link TBA) for more info about how to use the auto-generated classes.</p>

<h3 id="autoloading-with-zeitwerk">Autoloading with Zeitwerk</h3>

<p>Because the classes generated from the OAPI spec number in the hundreds, it’s a waste of memory and time to load all of them in every time you <code>require ruby-jss</code>, since most of them will never be used for any given application.</p>

<p>To deal with this, ruby-jss now uses the wonderfully cool <a href="https://github.com/fxn/zeitwerk">Zeitwerk gem</a> to automatically load only the files needed for classes and modules as they are used.</p>

<p>In fact, if you’d like to see it in action, just <code>touch /tmp/ruby-jss-verbose-loading</code> or <code>export RUBY_JSS_VERBOSE_LOADING=1</code> before you <code>require ruby-jss</code>.
Then as files load, lines will be written to standard error indicating:</p>

<ul>
  <li>Zeitwerk just loaded something from a file</li>
  <li>A module was mixed-in to some other module or class</li>
  <li>A method was just automatically defined</li>
</ul>

<h2 id="notable-changes-from-ruby-jss-1x">Notable changes from ruby-jss 1.x</h2>

<h3 id="paged-queries-to-the-jamf-pro-api">Paged queries to the Jamf Pro API</h3>

<p>In the previous Jamf module, to get paged API results from a list of all objects in a collection, you would use the <code>page_size:</code> and <code>page:</code> parameters to the <code>.all</code> class method, and then use <code>.next_page_of_all</code> to get subsequent pages. Unfortunately the way this happened was not threadsafe.</p>

<p>Now to get paged results, use the <code>.pager</code> class method, optionally sorted and filtered, as with <code>.all</code>. You’ll be given a <code>Jamf::Pager</code> object, which you can then use to retrieve sequential or arbitrary pages from the query.</p>

<p>The <code>.all</code> method will never deliver paged results, however if you give it a <code>filter</code> parameter for classes that support filtering, then <code>.all</code> returns “all that match the filter”, which may be fewer than the entire collection.</p>

<h3 id="api-data-are-no-longer-cached-">API data are no longer cached (?)</h3>

<p><strong>NOTE:</strong> As of this writing, caching has been removed for the objects from the Jamf Pro API, but caching remains in the Classic API. Its removal, or the re-instatement of caching for JP API objects, are pending discussion with users of ruby-jss.</p>

<p>Pre-2.0, methods that would fetch large datasets from the server would always cache that data in the Connection object, and by default use the cache in future calls unless a <code>refresh</code> parameter is given. These datasets included:</p>

<ul>
  <li>collection lists, used by <code>.all</code> and friends, like <code>.all_ids</code> and <code>.valid_id</code></li>
  <li>Extension Attribute, definitions, used for validating Extension Attribute values</li>
</ul>

<p>In 2.0+, that caching has been removed for objects from them Jamf Pro API.</p>

<p>If you want to avoid repeated GET requests to the server when you aren’t worried that the resulting data may have changed, you can store the results of <code>.all</code> in a variable, and either use it yourself, or pass it in to other methods via the <code>cached_list:</code> parameter. Passing in a cached_list wil prevent those methods from calling <code>.all</code> and reaching out to the server again.</p>

<p><strong>WARNING</strong>: Be careful that the list you pass in via <code>cached_list</code> contains the correct data structure for the class, and came from the desired Connection instance.</p>

<h3 id="no-attribute-aliases-for-jamf-pro-api-objects">No Attribute aliases for Jamf Pro API objects</h3>

<p>Objects from the Jamf Pro API will no longer define aliases for the attribute names that come from the API itself. This means, e.g., to get the name of a ComputerPrestage or MobileDevicePrestage, you have to ask for its <code>displayName</code> not its <code>name</code>, since the property comes from the API as <code>displayName</code>. To see a list  of all the names, you must use <code>.all_displayNames</code> not <code>.all_names</code>.  For objects with a ‘name’ property (most of them) then you can use <code>.name</code> and <code>.all_names</code>.</p>

<p>The reason behind this is twofold: 1) to simplify ruby-jss’s code and automate as much as possible; 2) to reflect what Jamf actually gives us in the APIs.</p>

<p>This is a breaking change from earlier ruby-jss versions, for which Jamf Pro API objects had the potential for aliases of their attribute names.</p>

<h3 id="classmixin-hierarchy-for-jamf-pro-api-objects">Class/Mixin hierarchy for Jamf Pro API objects</h3>

<p>If you contribute to ruby-jss, be aware that the structure of superclasses, subclasses, and mixin modules, and their file locations has changed drastically. Also changed is how to implement new objects using the OAPI auto-generated classes. These changes are due to using the auto-generated classes, as well as using Zeitwerk to autoload everything.</p>

<p>There’s a lot to document about these changes, and much of the current documentation is out of date, referring to how things were done when the Jamf module was separate and only talked to the Jamf Pro API.</p>

<p>Give us time and we’ll get everything updated. In the meantime, feel free to reach out in the #ruby-jss channel of Macadmins Slack, or open an issue on GitHub, or email ruby-jss@pixar.com.</p>

<h2 id="planned-deprecations">Planned deprecations</h2>

<h3 id="use-of-the-term-api-in-method-names-parameter-names-and-attributes">Use of the term ‘api’ in method names, parameter names, and attributes</h3>

<p>Use <code>cnx</code> instead. Example:</p>

<p>```ruby
my_connection = Jamf::Connection.new ‘https://user@my.jamf.server:8443/’, pw: :prompt</p>

<h1 id="old">OLD</h1>
<p>JSS::Computer.all_names api: my_connection</p>

<h1 id="new">NEW</h1>
<p>JSS::Computer.all_names cnx: my_connection</p>

<h1 id="old-1">OLD</h1>
<p>comp = JSS::Computer.fetch name: 12, api: my_connection
comp.api # =&gt; my_connection</p>

<h1 id="new-1">NEW</h1>
<p>comp = JSS::Computer.fetch id: 12, cnx: my_connection
comp.cnx # =&gt; my_connection
```</p>

<p>In ruby-jss &lt; 2.0, the term <code>api</code> is used with the Classic API in method names, method parameters, instance variables, attributes, and constants. It is used to pass, access, or hold instances of JSS::APIConnnection, e.g. so a method that talks to the server would use the passed connection rather than the module-wide default connection.  But, the thing being passed is a ‘connection’ not an ‘API’, and now that there are actually two APIs at play, that usage is even less appropriate.</p>

<p>The Original Jamf module, which accessed only the Jamf Pro API, has always used the better-suited abbreviation <code>cnx</code> for this, and now that is standard everywhere. For now <code>api</code> should continue to work, but it will be removed ‘eventually’, so please start changing your code now.</p>

<p>Accordingly, <code>JSS::API</code> (which should never have been a constant to begin with) is also deprecated. To access the default connection, use <code>Jamf.cnx</code></p>

<h3 id="mapallidsto-method-for-classic-api-collection-classes"><code>.map_all_ids_to</code> method for Classic API collection classes</h3>

<p>The <code>map_all_ids_to</code> method for the Classic API collection classes has been superceded by the more flexible <code>map_all</code> method, bringing it in-line with the Jamf Pro API classes.</p>

<p>For now <code>map_all_ids_to</code> still works, however it’s just a wrapper for <code>map_all</code>. Eventually the older method will be removed.</p>

<h3 id="using-make-create-and-update-for-classic-api-objects">Using <code>.make</code>, <code>#create</code>, and <code>#update</code> for Classic API objects</h3>

<p>Use <code>.create</code> and <code>#save</code> instead, as with the Jamf Pro API objects</p>

<p>In previous ruby-jss, both APIs avoided the use of the ruby-standard <code>.new</code> on Collection Resource classes, because the word ‘new’ in this context is ambiguous: are you creating a new instance of the class in ruby (which might already exist on the server), or are you creating a new object in Jamf Pro that doesn’t yet exist on the server?</p>

<p>In v2.0.0 we are standardizing on the behavior of the previous Jamf module:</p>

<ul>
  <li>
    <p><code>Jamf::SomeCollectionClass.create</code> class method for instantiating a ruby object to be added as a new SomeCollectionClass object to Jamf Pro</p>
  </li>
  <li>
    <p><code>Jamf::SomeCollectionClass#save</code> instance method for sending an object to the server to be created OR updated in Jamf pro.</p>
    <ul>
      <li>Note that <code>#save</code> has been available for this use since the earliest versions of ruby-jss.</li>
    </ul>
  </li>
</ul>

<p>This means that these deprecated methods will go away for Classic API objects</p>

<ul>
  <li><code>Jamf::SomeCollectionClass.make</code> class method for instantiating a ruby object to be added as a new SomeCollectionClass to Jamf Pro
    <ul>
      <li>use <code>Jamf::SomeCollectionClass.create</code> instead</li>
    </ul>
  </li>
  <li><code>Jamf::SomeCollectionClass#create</code> instance method for sending a new object to the API to be created on the server.
    <ul>
      <li>Use <code>Jamf::SomeCollectionClass#save</code> instead.</li>
      <li>Note that <code>#save</code> has been a wrapper for both <code>#create</code> and <code>#update</code> since the earliest versions of ruby-jss.</li>
    </ul>
  </li>
  <li><code>Jamf::SomeCollectionClass#update</code> instance method for then sending changes to an existing object to the API to be update on the server.
    <ul>
      <li>Use <code>Jamf::SomeCollectionClass#save</code> instead.</li>
      <li>Note that <code>#save</code> has been a wrapper for both <code>#create</code> and <code>#update</code> since the earliest versions of ruby-jss.</li>
    </ul>
  </li>
</ul>

<p>```ruby
# OLD</p>

<h1 id="get-a-ruby-instance-of-a-new-policy-to-be-added-to-jamf-pro">Get a ruby instance of a new policy to be added to Jamf Pro</h1>
<p>new_policy = Jamf::Policy.make name: ‘my-policy’
# … set other values for the policy, then
# Create it in Jamf Pro
new_policy.create # new_policy.save has always been a synonym</p>

<h1 id="fetch-an-existing-policy-from-the-server">fetch an existing policy from the server</h1>
<p>existing_policy = Jamf::Policy.fetch name: ‘older-policy’
# … change some values for the policy, then
# Update it in Jamf Pro
existing_policy.update # existing_policy.save has always been a synonym</p>

<h1 id="new-2">NEW</h1>

<h1 id="get-a-ruby-instance-of-a-new-policy-to-be-added-to-jamf-pro-1">Get a ruby instance of a new policy to be added to Jamf Pro</h1>
<p>new_policy = Jamf::Policy.create name: ‘my-policy’
# … set other values for the policy, then
# Create it in Jamf Pro
new_policy.save</p>

<h1 id="fetch-an-existing-policy-from-the-server-1">fetch an existing policy from the server</h1>
<p>existing_policy = Jamf::Policy.fetch name: ‘older-policy’
# … change some values for the policy, then
# Update it in Jamf Pro
existing_policy.save
```</p>

<h3 id="jssconfig">JSS::CONFIG</h3>

<p>This also should never have been a constant.  Use Jamf.config.  JSS::CONFIG will go away eventually.</p>

<h3 id="jamfconnection-instance-methods-nextrefresh-secstorefresh---timetorefresh">Jamf::Connection instance methods <code>#next_refresh</code>, <code>#secs_to_refresh</code>, &amp;  <code>#time_to_refresh</code></h3>

<p>These values are actually part of the token used by the connection, not the conection itself. Replace them with <code>#token.next_refresh</code>, <code>#token.secs_to_refresh</code>, &amp; <code>#token.time_to_refresh</code></p>

<h3 id="cross-object-validation-in-setters">Cross-object validation in setters</h3>

<p>Most ‘setters’ (methods that let you set values for the attributes of an object) in ruby-jss perform some kind of validation to make sure the value you’re trying to set is valid for that attribute. While still true, in v2.0 and up, this validation will be much more limited, mostly to ensuring the new value is of the correct type, e.g. an integer or a string, or a Jamf::Timestamp.</p>

<p>Objects from the Classic API have also provided validation that goes beyond that - using other API objects as needed to ‘pre-validate’ your data in the setter method.</p>

<p>For example, If you try to target a Policy scope to a certain ComputerGroup, when you use <code>my_policy.scope.add_target :computer_group, 1234</code> ruby-jss will use the Classic API to confirm that there actually is a computer group with the id 1234. If not, it will raise an exception.</p>

<p>Or when you try to set the value of an extension attribute on a Computer object, ruby-jss will retrieve the details of the ComputerExtensionAttribute definition from the api, and make sure that the value you are setting is valid - the data type, and if a Popup Menu is the input, the value is one of the popup choices.</p>

<p>This validation happens before you try to send the new data to the server.</p>

<p>This type of pre-validation will be removed over time from objects in the Classic API, for 3 reasons:</p>

<p>1) The API itself will perform this validation when you send the data, and will return an error if there’s a problem.
2) Removing this validation will simplify the code, and reduce interdependency between objects
3) Removing this code will make it easier to understand the permissions needed to do things in ruby-jss</p>

<p>The last point is very important.  Right now, in order to be able to manipulate the scope of any scopable object, the account with which you’re accessing the API must have at least ‘read’ permission on all the different kinds of objects that <em>might</em> be in the scope: computers, computer groups, buildings, departments, network segments, and so on. Removing or limiting the validation-based interdependency will make it easier to limit the access needed for API service accounts, and thereby increase overall security.</p>

<h3 id="fetch-random">.fetch :random</h3>

<p>You can still fetch random objects from a collection, but use <code>.fetch random: true</code>. The older <code>.fetch :random</code> is deprecated and will be removed.</p>

<h2 id="how-to-install-for-testing">How to install for testing</h2>

<p><code>gem install ruby-jss --version 2.0.0xy</code></p>

<p>where x is a or b, and y is the alpha or beta number</p>

<p>You can also clone the GitHub repo, cd into the top level of the project and run <code>gem build ruby-jss.gemspec</code>, then install the resulting gem.</p>

<h2 id="contact">Contact</h2>

<p>If you have questions or feedback about all this, please reach out in the #ruby-jss channel of Macadmins Slack, or open an issue on GitHub, or email ruby-jss@pixar.com.</p>
</div></div>

      <div id="footer">
  Generated on Wed Apr 20 17:10:10 2022 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.25 (ruby-2.6.3).
</div>

    </div>
  </body>
</html>